module.exports=[34951,79296,54588,17046,a=>{"use strict";let b=[0,2e3,1e4,3e4,null];class c{constructor(a){this._retryDelays=void 0!==a?[...a,null]:b}nextRetryDelayInMilliseconds(a){return this._retryDelays[a.previousRetryCount]}}a.s(["DefaultReconnectPolicy",()=>c],34951);class d{}d.Authorization="Authorization",d.Cookie="Cookie",a.s(["HeaderNames",()=>d],79296);class e{constructor(a,b,c){this.statusCode=a,this.statusText=b,this.content=c}}class f{get(a,b){return this.send({...b,method:"GET",url:a})}post(a,b){return this.send({...b,method:"POST",url:a})}delete(a,b){return this.send({...b,method:"DELETE",url:a})}getCookieString(a){return""}}a.s(["HttpClient",()=>f,"HttpResponse",()=>e],54588);class g extends f{constructor(a,b){super(),this._innerClient=a,this._accessTokenFactory=b}async send(a){let b=!0;this._accessTokenFactory&&(!this._accessToken||a.url&&a.url.indexOf("/negotiate?")>0)&&(b=!1,this._accessToken=await this._accessTokenFactory()),this._setAuthorizationHeader(a);let c=await this._innerClient.send(a);return b&&401===c.statusCode&&this._accessTokenFactory?(this._accessToken=await this._accessTokenFactory(),this._setAuthorizationHeader(a),await this._innerClient.send(a)):c}_setAuthorizationHeader(a){a.headers||(a.headers={}),this._accessToken?a.headers[d.Authorization]=`Bearer ${this._accessToken}`:this._accessTokenFactory&&a.headers[d.Authorization]&&delete a.headers[d.Authorization]}getCookieString(a){return this._innerClient.getCookieString(a)}}a.s(["AccessTokenHttpClient",()=>g],17046)},15591,a=>{"use strict";class b extends Error{constructor(a,b){const c=new.target.prototype;super(`${a}: Status code '${b}'`),this.statusCode=b,this.__proto__=c}}class c extends Error{constructor(a="A timeout occurred."){const b=new.target.prototype;super(a),this.__proto__=b}}class d extends Error{constructor(a="An abort occurred."){const b=new.target.prototype;super(a),this.__proto__=b}}class e extends Error{constructor(a,b){const c=new.target.prototype;super(a),this.transport=b,this.errorType="UnsupportedTransportError",this.__proto__=c}}class f extends Error{constructor(a,b){const c=new.target.prototype;super(a),this.transport=b,this.errorType="DisabledTransportError",this.__proto__=c}}class g extends Error{constructor(a,b){const c=new.target.prototype;super(a),this.transport=b,this.errorType="FailedToStartTransportError",this.__proto__=c}}class h extends Error{constructor(a){const b=new.target.prototype;super(a),this.errorType="FailedToNegotiateWithServerError",this.__proto__=b}}class i extends Error{constructor(a,b){const c=new.target.prototype;super(a),this.innerErrors=b,this.__proto__=c}}a.s(["AbortError",()=>d,"AggregateErrors",()=>i,"DisabledTransportError",()=>f,"FailedToNegotiateWithServerError",()=>h,"FailedToStartTransportError",()=>g,"HttpError",()=>b,"TimeoutError",()=>c,"UnsupportedTransportError",()=>e])},71473,53692,82968,a=>{"use strict";var b,c;(c=b||(b={}))[c.Trace=0]="Trace",c[c.Debug=1]="Debug",c[c.Information=2]="Information",c[c.Warning=3]="Warning",c[c.Error=4]="Error",c[c.Critical=5]="Critical",c[c.None=6]="None",a.s(["LogLevel",()=>b],53692);class d{constructor(){}log(a,b){}}d.instance=new d,a.s(["NullLogger",()=>d],82968);class e{static isRequired(a,b){if(null==a)throw Error(`The '${b}' argument is required.`)}static isNotEmpty(a,b){if(!a||a.match(/^\s*$/))throw Error(`The '${b}' argument should not be empty.`)}static isIn(a,b,c){if(!(a in b))throw Error(`Unknown ${c} value: ${a}.`)}}class f{static get isBrowser(){return!f.isNode&&!1}static get isWebWorker(){return!f.isNode&&"object"==typeof self&&"importScripts"in self}static get isReactNative(){return!f.isNode&&!1}static get isNode(){return"undefined"!=typeof process&&process.release&&"node"===process.release.name}}function g(a,b){let c,d,e="";return h(a)?(e=`Binary data of length ${a.byteLength}`,b&&(e+=`. Content: '${c=new Uint8Array(a),d="",c.forEach(a=>{let b=a<16?"0":"";d+=`0x${b}${a.toString(16)} `}),d.substring(0,d.length-1)}'`)):"string"==typeof a&&(e=`String data of length ${a.length}`,b&&(e+=`. Content: '${a}'`)),e}function h(a){return a&&"undefined"!=typeof ArrayBuffer&&(a instanceof ArrayBuffer||a.constructor&&"ArrayBuffer"===a.constructor.name)}async function i(a,c,d,e,f,i){let j={},[k,l]=m();j[k]=l,a.log(b.Trace,`(${c} transport) sending data. ${g(f,i.logMessageContent)}.`);let n=h(f)?"arraybuffer":"text",o=await d.post(e,{content:f,headers:{...j,...i.headers},responseType:n,timeout:i.timeout,withCredentials:i.withCredentials});a.log(b.Trace,`(${c} transport) request complete. Response status: ${o.statusCode}.`)}function j(a){return void 0===a?new l(b.Information):null===a?d.instance:void 0!==a.log?a:new l(a)}class k{constructor(a,b){this._subject=a,this._observer=b}dispose(){let a=this._subject.observers.indexOf(this._observer);a>-1&&this._subject.observers.splice(a,1),0===this._subject.observers.length&&this._subject.cancelCallback&&this._subject.cancelCallback().catch(a=>{})}}class l{constructor(a){this._minLevel=a,this.out=console}log(a,c){if(a>=this._minLevel){let d=`[${new Date().toISOString()}] ${b[a]}: ${c}`;switch(a){case b.Critical:case b.Error:this.out.error(d);break;case b.Warning:this.out.warn(d);break;case b.Information:this.out.info(d);break;default:this.out.log(d)}}}}function m(){var a,b,c,d;let e,g,h="X-SignalR-User-Agent";return f.isNode&&(h="User-Agent"),[h,(a="10.0.0",b=function(){if(!f.isNode)return"";switch(process.platform){case"win32":return"Windows NT";case"darwin":return"macOS";case"linux":return"Linux";default:return process.platform}}(),c=f.isNode?"NodeJS":"Browser",d=function(){if(f.isNode)return process.versions.node}(),e="Microsoft SignalR/",g=a.split("."),e+=`${g[0]}.${g[1]} (${a}; `,b&&""!==b?e+=`${b}; `:e+="Unknown OS; ",e+=`${c}`,d?e+=`; ${d}`:e+="; Unknown Runtime Version",e+=")")]}function n(a){return a.stack?a.stack:a.message?a.message:`${a}`}function o(){return"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:a.g}a.s(["Arg",()=>e,"ConsoleLogger",()=>l,"Platform",()=>f,"SubjectSubscription",()=>k,"createLogger",()=>j,"getDataDetail",()=>g,"getErrorString",()=>n,"getGlobalThis",()=>o,"getUserAgentHeader",()=>m,"isArrayBuffer",()=>h,"sendMessage",()=>i],71473)},20316,65581,a=>{"use strict";var b,c,d,e,f=a.i(17046),g=a.i(15591),h=a.i(54588),i=a.i(53692),j=a.i(71473);class k extends h.HttpClient{constructor(b){if(super(),this._logger=b,"undefined"==typeof fetch||j.Platform.isNode){const b="function"==typeof __webpack_require__?__non_webpack_require__:a.z;this._jar=new(b("tough-cookie")).CookieJar,"undefined"==typeof fetch?this._fetchType=b("node-fetch"):this._fetchType=fetch,this._fetchType=b("fetch-cookie")(this._fetchType,this._jar)}else this._fetchType=fetch.bind((0,j.getGlobalThis)());if("undefined"==typeof AbortController){const b="function"==typeof __webpack_require__?__non_webpack_require__:a.z;this._abortControllerType=b("abort-controller")}else this._abortControllerType=AbortController}async send(a){let b,c;if(a.abortSignal&&a.abortSignal.aborted)throw new g.AbortError;if(!a.method)throw Error("No method defined.");if(!a.url)throw Error("No url defined.");let d=new this._abortControllerType;a.abortSignal&&(a.abortSignal.onabort=()=>{d.abort(),b=new g.AbortError});let e=null;a.timeout&&(e=setTimeout(()=>{d.abort(),this._logger.log(i.LogLevel.Warning,"Timeout from HTTP request."),b=new g.TimeoutError},a.timeout)),""===a.content&&(a.content=void 0),a.content&&(a.headers=a.headers||{},(0,j.isArrayBuffer)(a.content)?a.headers["Content-Type"]="application/octet-stream":a.headers["Content-Type"]="text/plain;charset=UTF-8");try{c=await this._fetchType(a.url,{body:a.content,cache:"no-cache",credentials:!0===a.withCredentials?"include":"same-origin",headers:{"X-Requested-With":"XMLHttpRequest",...a.headers},method:a.method,mode:"cors",redirect:"follow",signal:d.signal})}catch(a){if(b)throw b;throw this._logger.log(i.LogLevel.Warning,`Error from HTTP request. ${a}.`),a}finally{e&&clearTimeout(e),a.abortSignal&&(a.abortSignal.onabort=null)}if(!c.ok){let a=await l(c,"text");throw new g.HttpError(a||c.statusText,c.status)}let f=l(c,a.responseType),k=await f;return new h.HttpResponse(c.status,c.statusText,k)}getCookieString(a){let b="";return j.Platform.isNode&&this._jar&&this._jar.getCookies(a,(a,c)=>b=c.join("; ")),b}}function l(a,b){let c;switch(b){case"arraybuffer":c=a.arrayBuffer();break;case"text":default:c=a.text();break;case"blob":case"document":case"json":throw Error(`${b} is not supported.`)}return c}var m=h,n=h;class o extends n.HttpClient{constructor(a){super(),this._logger=a}send(a){return a.abortSignal&&a.abortSignal.aborted?Promise.reject(new g.AbortError):a.method?a.url?new Promise((b,c)=>{let d=new XMLHttpRequest;d.open(a.method,a.url,!0),d.withCredentials=void 0===a.withCredentials||a.withCredentials,d.setRequestHeader("X-Requested-With","XMLHttpRequest"),""===a.content&&(a.content=void 0),a.content&&((0,j.isArrayBuffer)(a.content)?d.setRequestHeader("Content-Type","application/octet-stream"):d.setRequestHeader("Content-Type","text/plain;charset=UTF-8"));let e=a.headers;e&&Object.keys(e).forEach(a=>{d.setRequestHeader(a,e[a])}),a.responseType&&(d.responseType=a.responseType),a.abortSignal&&(a.abortSignal.onabort=()=>{d.abort(),c(new g.AbortError)}),a.timeout&&(d.timeout=a.timeout),d.onload=()=>{a.abortSignal&&(a.abortSignal.onabort=null),d.status>=200&&d.status<300?b(new n.HttpResponse(d.status,d.statusText,d.response||d.responseText)):c(new g.HttpError(d.response||d.responseText||d.statusText,d.status))},d.onerror=()=>{this._logger.log(i.LogLevel.Warning,`Error from HTTP request. ${d.status}: ${d.statusText}.`),c(new g.HttpError(d.statusText,d.status))},d.ontimeout=()=>{this._logger.log(i.LogLevel.Warning,"Timeout from HTTP request."),c(new g.TimeoutError)},d.send(a.content)}):Promise.reject(Error("No url defined.")):Promise.reject(Error("No method defined."))}}class p extends m.HttpClient{constructor(a){if(super(),"undefined"!=typeof fetch||j.Platform.isNode)this._httpClient=new k(a);else if("undefined"!=typeof XMLHttpRequest)this._httpClient=new o(a);else throw Error("No usable HttpClient found.")}send(a){return a.abortSignal&&a.abortSignal.aborted?Promise.reject(new g.AbortError):a.method?a.url?this._httpClient.send(a):Promise.reject(Error("No url defined.")):Promise.reject(Error("No method defined."))}getCookieString(a){return this._httpClient.getCookieString(a)}}(b=d||(d={}))[b.None=0]="None",b[b.WebSockets=1]="WebSockets",b[b.ServerSentEvents=2]="ServerSentEvents",b[b.LongPolling=4]="LongPolling",(c=e||(e={}))[c.Text=1]="Text",c[c.Binary=2]="Binary",a.s(["HttpTransportType",()=>d,"TransferFormat",()=>e],65581);class q{constructor(){this._isAborted=!1,this.onabort=null}abort(){!this._isAborted&&(this._isAborted=!0,this.onabort&&this.onabort())}get signal(){return this}get aborted(){return this._isAborted}}class r{get pollAborted(){return this._pollAbort.aborted}constructor(a,b,c){this._httpClient=a,this._logger=b,this._pollAbort=new q,this._options=c,this._running=!1,this.onreceive=null,this.onclose=null}async connect(a,b){if(j.Arg.isRequired(a,"url"),j.Arg.isRequired(b,"transferFormat"),j.Arg.isIn(b,e,"transferFormat"),this._url=a,this._logger.log(i.LogLevel.Trace,"(LongPolling transport) Connecting."),b===e.Binary&&"undefined"!=typeof XMLHttpRequest&&"string"!=typeof new XMLHttpRequest().responseType)throw Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");let[c,d]=(0,j.getUserAgentHeader)(),f={[c]:d,...this._options.headers},h={abortSignal:this._pollAbort.signal,headers:f,timeout:1e5,withCredentials:this._options.withCredentials};b===e.Binary&&(h.responseType="arraybuffer");let k=`${a}&_=${Date.now()}`;this._logger.log(i.LogLevel.Trace,`(LongPolling transport) polling: ${k}.`);let l=await this._httpClient.get(k,h);200!==l.statusCode?(this._logger.log(i.LogLevel.Error,`(LongPolling transport) Unexpected response code: ${l.statusCode}.`),this._closeError=new g.HttpError(l.statusText||"",l.statusCode),this._running=!1):this._running=!0,this._receiving=this._poll(this._url,h)}async _poll(a,b){try{for(;this._running;)try{let c=`${a}&_=${Date.now()}`;this._logger.log(i.LogLevel.Trace,`(LongPolling transport) polling: ${c}.`);let d=await this._httpClient.get(c,b);204===d.statusCode?(this._logger.log(i.LogLevel.Information,"(LongPolling transport) Poll terminated by server."),this._running=!1):200!==d.statusCode?(this._logger.log(i.LogLevel.Error,`(LongPolling transport) Unexpected response code: ${d.statusCode}.`),this._closeError=new g.HttpError(d.statusText||"",d.statusCode),this._running=!1):d.content?(this._logger.log(i.LogLevel.Trace,`(LongPolling transport) data received. ${(0,j.getDataDetail)(d.content,this._options.logMessageContent)}.`),this.onreceive&&this.onreceive(d.content)):this._logger.log(i.LogLevel.Trace,"(LongPolling transport) Poll timed out, reissuing.")}catch(a){this._running?a instanceof g.TimeoutError?this._logger.log(i.LogLevel.Trace,"(LongPolling transport) Poll timed out, reissuing."):(this._closeError=a,this._running=!1):this._logger.log(i.LogLevel.Trace,`(LongPolling transport) Poll errored after shutdown: ${a.message}`)}}finally{this._logger.log(i.LogLevel.Trace,"(LongPolling transport) Polling complete."),this.pollAborted||this._raiseOnClose()}}async send(a){return this._running?(0,j.sendMessage)(this._logger,"LongPolling",this._httpClient,this._url,a,this._options):Promise.reject(Error("Cannot send until the transport is connected"))}async stop(){this._logger.log(i.LogLevel.Trace,"(LongPolling transport) Stopping polling."),this._running=!1,this._pollAbort.abort();try{let a;await this._receiving,this._logger.log(i.LogLevel.Trace,`(LongPolling transport) sending DELETE request to ${this._url}.`);let b={},[c,d]=(0,j.getUserAgentHeader)();b[c]=d;let e={headers:{...b,...this._options.headers},timeout:this._options.timeout,withCredentials:this._options.withCredentials};try{await this._httpClient.delete(this._url,e)}catch(b){a=b}a?a instanceof g.HttpError&&(404===a.statusCode?this._logger.log(i.LogLevel.Trace,"(LongPolling transport) A 404 response was returned from sending a DELETE request."):this._logger.log(i.LogLevel.Trace,`(LongPolling transport) Error sending a DELETE request: ${a}`)):this._logger.log(i.LogLevel.Trace,"(LongPolling transport) DELETE request accepted.")}finally{this._logger.log(i.LogLevel.Trace,"(LongPolling transport) Stop finished."),this._raiseOnClose()}}_raiseOnClose(){if(this.onclose){let a="(LongPolling transport) Firing onclose event.";this._closeError&&(a+=" Error: "+this._closeError),this._logger.log(i.LogLevel.Trace,a),this.onclose(this._closeError)}}}class s{constructor(a,b,c,d){this._httpClient=a,this._accessToken=b,this._logger=c,this._options=d,this.onreceive=null,this.onclose=null}async connect(a,b){return j.Arg.isRequired(a,"url"),j.Arg.isRequired(b,"transferFormat"),j.Arg.isIn(b,e,"transferFormat"),this._logger.log(i.LogLevel.Trace,"(SSE transport) Connecting."),this._url=a,this._accessToken&&(a+=(0>a.indexOf("?")?"?":"&")+`access_token=${encodeURIComponent(this._accessToken)}`),new Promise((c,d)=>{let f,g=!1;if(b!==e.Text)return void d(Error("The Server-Sent Events transport only supports the 'Text' transfer format"));if(j.Platform.isBrowser||j.Platform.isWebWorker)f=new this._options.EventSource(a,{withCredentials:this._options.withCredentials});else{let b=this._httpClient.getCookieString(a),c={};c.Cookie=b;let[d,e]=(0,j.getUserAgentHeader)();c[d]=e,f=new this._options.EventSource(a,{withCredentials:this._options.withCredentials,headers:{...c,...this._options.headers}})}try{f.onmessage=a=>{if(this.onreceive)try{this._logger.log(i.LogLevel.Trace,`(SSE transport) data received. ${(0,j.getDataDetail)(a.data,this._options.logMessageContent)}.`),this.onreceive(a.data)}catch(a){this._close(a);return}},f.onerror=a=>{g?this._close():d(Error("EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled."))},f.onopen=()=>{this._logger.log(i.LogLevel.Information,`SSE connected to ${this._url}`),this._eventSource=f,g=!0,c()}}catch(a){d(a);return}})}async send(a){return this._eventSource?(0,j.sendMessage)(this._logger,"SSE",this._httpClient,this._url,a,this._options):Promise.reject(Error("Cannot send until the transport is connected"))}stop(){return this._close(),Promise.resolve()}_close(a){this._eventSource&&(this._eventSource.close(),this._eventSource=void 0,this.onclose&&this.onclose(a))}}var t=a.i(79296);class u{constructor(a,b,c,d,e,f){this._logger=c,this._accessTokenFactory=b,this._logMessageContent=d,this._webSocketConstructor=e,this._httpClient=a,this.onreceive=null,this.onclose=null,this._headers=f}async connect(a,b){let c;return j.Arg.isRequired(a,"url"),j.Arg.isRequired(b,"transferFormat"),j.Arg.isIn(b,e,"transferFormat"),this._logger.log(i.LogLevel.Trace,"(WebSockets transport) Connecting."),this._accessTokenFactory&&(c=await this._accessTokenFactory()),new Promise((d,f)=>{let g;a=a.replace(/^http/,"ws");let h=this._httpClient.getCookieString(a),k=!1;if(j.Platform.isNode||j.Platform.isReactNative){let b={},[d,e]=(0,j.getUserAgentHeader)();b[d]=e,c&&(b[t.HeaderNames.Authorization]=`Bearer ${c}`),h&&(b[t.HeaderNames.Cookie]=h),g=new this._webSocketConstructor(a,void 0,{headers:{...b,...this._headers}})}else c&&(a+=(0>a.indexOf("?")?"?":"&")+`access_token=${encodeURIComponent(c)}`);g||(g=new this._webSocketConstructor(a)),b===e.Binary&&(g.binaryType="arraybuffer"),g.onopen=b=>{this._logger.log(i.LogLevel.Information,`WebSocket connected to ${a}.`),this._webSocket=g,k=!0,d()},g.onerror=a=>{let b=null;b="undefined"!=typeof ErrorEvent&&a instanceof ErrorEvent?a.error:"There was an error with the transport",this._logger.log(i.LogLevel.Information,`(WebSockets transport) ${b}.`)},g.onmessage=a=>{if(this._logger.log(i.LogLevel.Trace,`(WebSockets transport) data received. ${(0,j.getDataDetail)(a.data,this._logMessageContent)}.`),this.onreceive)try{this.onreceive(a.data)}catch(a){this._close(a);return}},g.onclose=a=>{if(k)this._close(a);else f(Error("undefined"!=typeof ErrorEvent&&a instanceof ErrorEvent?a.error:"WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled."))}})}send(a){return this._webSocket&&this._webSocket.readyState===this._webSocketConstructor.OPEN?(this._logger.log(i.LogLevel.Trace,`(WebSockets transport) sending data. ${(0,j.getDataDetail)(a,this._logMessageContent)}.`),this._webSocket.send(a),Promise.resolve()):Promise.reject("WebSocket is not in the OPEN state")}stop(){return this._webSocket&&this._close(void 0),Promise.resolve()}_close(a){this._webSocket&&(this._webSocket.onclose=()=>{},this._webSocket.onmessage=()=>{},this._webSocket.onerror=()=>{},this._webSocket.close(),this._webSocket=void 0),this._logger.log(i.LogLevel.Trace,"(WebSockets transport) socket closed."),this.onclose&&(this._isCloseEvent(a)&&(!1===a.wasClean||1e3!==a.code)?this.onclose(Error(`WebSocket closed with status code: ${a.code} (${a.reason||"no reason given"}).`)):a instanceof Error?this.onclose(a):this.onclose())}_isCloseEvent(a){return a&&"boolean"==typeof a.wasClean&&"number"==typeof a.code}}class v{constructor(b,c={}){if(this._stopPromiseResolver=()=>{},this.features={},this._negotiateVersion=1,j.Arg.isRequired(b,"url"),this._logger=(0,j.createLogger)(c.logger),this.baseUrl=this._resolveUrl(b),(c=c||{}).logMessageContent=void 0!==c.logMessageContent&&c.logMessageContent,"boolean"==typeof c.withCredentials||void 0===c.withCredentials)c.withCredentials=void 0===c.withCredentials||c.withCredentials;else throw Error("withCredentials option was not a 'boolean' or 'undefined' value");c.timeout=void 0===c.timeout?1e5:c.timeout;let d=null,e=null;if(j.Platform.isNode&&1){const b="function"==typeof __webpack_require__?__non_webpack_require__:a.z;d=b("ws"),e=b("eventsource")}j.Platform.isNode||"undefined"==typeof WebSocket||c.WebSocket?j.Platform.isNode&&!c.WebSocket&&d&&(c.WebSocket=d):c.WebSocket=WebSocket,j.Platform.isNode||"undefined"==typeof EventSource||c.EventSource?j.Platform.isNode&&!c.EventSource&&void 0!==e&&(c.EventSource=e):c.EventSource=EventSource,this._httpClient=new f.AccessTokenHttpClient(c.httpClient||new p(this._logger),c.accessTokenFactory),this._connectionState="Disconnected",this._connectionStarted=!1,this._options=c,this.onreceive=null,this.onclose=null}async start(a){if(a=a||e.Binary,j.Arg.isIn(a,e,"transferFormat"),this._logger.log(i.LogLevel.Debug,`Starting connection with transfer format '${e[a]}'.`),"Disconnected"!==this._connectionState)return Promise.reject(Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."));if(this._connectionState="Connecting",this._startInternalPromise=this._startInternal(a),await this._startInternalPromise,"Disconnecting"===this._connectionState){let a="Failed to start the HttpConnection before stop() was called.";return this._logger.log(i.LogLevel.Error,a),await this._stopPromise,Promise.reject(new g.AbortError(a))}if("Connected"!==this._connectionState){let a="HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!";return this._logger.log(i.LogLevel.Error,a),Promise.reject(new g.AbortError(a))}this._connectionStarted=!0}send(a){return"Connected"!==this._connectionState?Promise.reject(Error("Cannot send data if the connection is not in the 'Connected' State.")):(this._sendQueue||(this._sendQueue=new w(this.transport)),this._sendQueue.send(a))}async stop(a){return"Disconnected"===this._connectionState?(this._logger.log(i.LogLevel.Debug,`Call to HttpConnection.stop(${a}) ignored because the connection is already in the disconnected state.`),Promise.resolve()):"Disconnecting"===this._connectionState?(this._logger.log(i.LogLevel.Debug,`Call to HttpConnection.stop(${a}) ignored because the connection is already in the disconnecting state.`),this._stopPromise):void(this._connectionState="Disconnecting",this._stopPromise=new Promise(a=>{this._stopPromiseResolver=a}),await this._stopInternal(a),await this._stopPromise)}async _stopInternal(a){this._stopError=a;try{await this._startInternalPromise}catch(a){}if(this.transport){try{await this.transport.stop()}catch(a){this._logger.log(i.LogLevel.Error,`HttpConnection.transport.stop() threw error '${a}'.`),this._stopConnection()}this.transport=void 0}else this._logger.log(i.LogLevel.Debug,"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.")}async _startInternal(a){let b=this.baseUrl;this._accessTokenFactory=this._options.accessTokenFactory,this._httpClient._accessTokenFactory=this._accessTokenFactory;try{if(this._options.skipNegotiation)if(this._options.transport===d.WebSockets)this.transport=this._constructTransport(d.WebSockets),await this._startTransport(b,a);else throw Error("Negotiation can only be skipped when using the WebSocket transport directly.");else{let c=null,d=0;do{if(c=await this._getNegotiationResponse(b),"Disconnecting"===this._connectionState||"Disconnected"===this._connectionState)throw new g.AbortError("The connection was stopped during negotiation.");if(c.error)throw Error(c.error);if(c.ProtocolVersion)throw Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");if(c.url&&(b=c.url),c.accessToken){let a=c.accessToken;this._accessTokenFactory=()=>a,this._httpClient._accessToken=a,this._httpClient._accessTokenFactory=void 0}d++}while(c.url&&d<100)if(100===d&&c.url)throw Error("Negotiate redirection limit exceeded.");await this._createTransport(b,this._options.transport,c,a)}this.transport instanceof r&&(this.features.inherentKeepAlive=!0),"Connecting"===this._connectionState&&(this._logger.log(i.LogLevel.Debug,"The HttpConnection connected successfully."),this._connectionState="Connected")}catch(a){return this._logger.log(i.LogLevel.Error,"Failed to start the connection: "+a),this._connectionState="Disconnected",this.transport=void 0,this._stopPromiseResolver(),Promise.reject(a)}}async _getNegotiationResponse(a){let b={},[c,d]=(0,j.getUserAgentHeader)();b[c]=d;let e=this._resolveNegotiateUrl(a);this._logger.log(i.LogLevel.Debug,`Sending negotiation request: ${e}.`);try{let a=await this._httpClient.post(e,{content:"",headers:{...b,...this._options.headers},timeout:this._options.timeout,withCredentials:this._options.withCredentials});if(200!==a.statusCode)return Promise.reject(Error(`Unexpected status code returned from negotiate '${a.statusCode}'`));let c=JSON.parse(a.content);if((!c.negotiateVersion||c.negotiateVersion<1)&&(c.connectionToken=c.connectionId),c.useStatefulReconnect&&!0!==this._options._useStatefulReconnect)return Promise.reject(new g.FailedToNegotiateWithServerError("Client didn't negotiate Stateful Reconnect but the server did."));return c}catch(b){let a="Failed to complete negotiation with the server: "+b;return b instanceof g.HttpError&&404===b.statusCode&&(a+=" Either this is not a SignalR endpoint or there is a proxy blocking the connection."),this._logger.log(i.LogLevel.Error,a),Promise.reject(new g.FailedToNegotiateWithServerError(a))}}_createConnectUrl(a,b){return b?a+(-1===a.indexOf("?")?"?":"&")+`id=${b}`:a}async _createTransport(a,b,c,e){let f=this._createConnectUrl(a,c.connectionToken);if(this._isITransport(b)){this._logger.log(i.LogLevel.Debug,"Connection was provided an instance of ITransport, using that directly."),this.transport=b,await this._startTransport(f,e),this.connectionId=c.connectionId;return}let h=[],j=c.availableTransports||[],k=c;for(let c of j){let j=this._resolveTransportOrError(c,b,e,(null==k?void 0:k.useStatefulReconnect)===!0);if(j instanceof Error)h.push(`${c.transport} failed:`),h.push(j);else if(this._isITransport(j)){if(this.transport=j,!k){try{k=await this._getNegotiationResponse(a)}catch(a){return Promise.reject(a)}f=this._createConnectUrl(a,k.connectionToken)}try{await this._startTransport(f,e),this.connectionId=k.connectionId;return}catch(a){if(this._logger.log(i.LogLevel.Error,`Failed to start the transport '${c.transport}': ${a}`),k=void 0,h.push(new g.FailedToStartTransportError(`${c.transport} failed: ${a}`,d[c.transport])),"Connecting"!==this._connectionState){let a="Failed to select transport before stop() was called.";return this._logger.log(i.LogLevel.Debug,a),Promise.reject(new g.AbortError(a))}}}}return h.length>0?Promise.reject(new g.AggregateErrors(`Unable to connect to the server with any of the available transports. ${h.join(" ")}`,h)):Promise.reject(Error("None of the transports supported by the client are supported by the server."))}_constructTransport(a){switch(a){case d.WebSockets:if(!this._options.WebSocket)throw Error("'WebSocket' is not supported in your environment.");return new u(this._httpClient,this._accessTokenFactory,this._logger,this._options.logMessageContent,this._options.WebSocket,this._options.headers||{});case d.ServerSentEvents:if(!this._options.EventSource)throw Error("'EventSource' is not supported in your environment.");return new s(this._httpClient,this._httpClient._accessToken,this._logger,this._options);case d.LongPolling:return new r(this._httpClient,this._logger,this._options);default:throw Error(`Unknown transport: ${a}.`)}}_startTransport(a,b){return this.transport.onreceive=this.onreceive,this.features.reconnect?this.transport.onclose=async c=>{let d=!1;if(!this.features.reconnect)return void this._stopConnection(c);try{this.features.disconnected(),await this.transport.connect(a,b),await this.features.resend()}catch{d=!0}d&&this._stopConnection(c)}:this.transport.onclose=a=>this._stopConnection(a),this.transport.connect(a,b)}_resolveTransportOrError(a,b,c,f){var h,j;let k=d[a.transport];if(null==k)return this._logger.log(i.LogLevel.Debug,`Skipping transport '${a.transport}' because it is not supported by this client.`),Error(`Skipping transport '${a.transport}' because it is not supported by this client.`);if(h=b,j=k,h&&(j&h)==0)return this._logger.log(i.LogLevel.Debug,`Skipping transport '${d[k]}' because it was disabled by the client.`),new g.DisabledTransportError(`'${d[k]}' is disabled by the client.`,k);if(!(a.transferFormats.map(a=>e[a]).indexOf(c)>=0))return this._logger.log(i.LogLevel.Debug,`Skipping transport '${d[k]}' because it does not support the requested transfer format '${e[c]}'.`),Error(`'${d[k]}' does not support ${e[c]}.`);if(k===d.WebSockets&&!this._options.WebSocket||k===d.ServerSentEvents&&!this._options.EventSource)return this._logger.log(i.LogLevel.Debug,`Skipping transport '${d[k]}' because it is not supported in your environment.'`),new g.UnsupportedTransportError(`'${d[k]}' is not supported in your environment.`,k);this._logger.log(i.LogLevel.Debug,`Selecting transport '${d[k]}'.`);try{return this.features.reconnect=k===d.WebSockets?f:void 0,this._constructTransport(k)}catch(a){return a}}_isITransport(a){return a&&"object"==typeof a&&"connect"in a}_stopConnection(a){if(this._logger.log(i.LogLevel.Debug,`HttpConnection.stopConnection(${a}) called while in state ${this._connectionState}.`),this.transport=void 0,a=this._stopError||a,this._stopError=void 0,"Disconnected"===this._connectionState)return void this._logger.log(i.LogLevel.Debug,`Call to HttpConnection.stopConnection(${a}) was ignored because the connection is already in the disconnected state.`);if("Connecting"===this._connectionState)throw this._logger.log(i.LogLevel.Warning,`Call to HttpConnection.stopConnection(${a}) was ignored because the connection is still in the connecting state.`),Error(`HttpConnection.stopConnection(${a}) was called while the connection is still in the connecting state.`);if("Disconnecting"===this._connectionState&&this._stopPromiseResolver(),a?this._logger.log(i.LogLevel.Error,`Connection disconnected with error '${a}'.`):this._logger.log(i.LogLevel.Information,"Connection disconnected."),this._sendQueue&&(this._sendQueue.stop().catch(a=>{this._logger.log(i.LogLevel.Error,`TransportSendQueue.stop() threw error '${a}'.`)}),this._sendQueue=void 0),this.connectionId=void 0,this._connectionState="Disconnected",this._connectionStarted){this._connectionStarted=!1;try{this.onclose&&this.onclose(a)}catch(b){this._logger.log(i.LogLevel.Error,`HttpConnection.onclose(${a}) threw error '${b}'.`)}}}_resolveUrl(a){if(0===a.lastIndexOf("https://",0)||0===a.lastIndexOf("http://",0))return a;if(!j.Platform.isBrowser)throw Error(`Cannot resolve '${a}'.`);let b=window.document.createElement("a");return b.href=a,this._logger.log(i.LogLevel.Information,`Normalizing '${a}' to '${b.href}'.`),b.href}_resolveNegotiateUrl(a){let b=new URL(a);b.pathname.endsWith("/")?b.pathname+="negotiate":b.pathname+="/negotiate";let c=new URLSearchParams(b.searchParams);return c.has("negotiateVersion")||c.append("negotiateVersion",this._negotiateVersion.toString()),c.has("useStatefulReconnect")?"true"===c.get("useStatefulReconnect")&&(this._options._useStatefulReconnect=!0):!0===this._options._useStatefulReconnect&&c.append("useStatefulReconnect","true"),b.search=c.toString(),b.toString()}}class w{constructor(a){this._transport=a,this._buffer=[],this._executing=!0,this._sendBufferedData=new x,this._transportResult=new x,this._sendLoopPromise=this._sendLoop()}send(a){return this._bufferData(a),this._transportResult||(this._transportResult=new x),this._transportResult.promise}stop(){return this._executing=!1,this._sendBufferedData.resolve(),this._sendLoopPromise}_bufferData(a){if(this._buffer.length&&typeof this._buffer[0]!=typeof a)throw Error(`Expected data to be of type ${typeof this._buffer} but was of type ${typeof a}`);this._buffer.push(a),this._sendBufferedData.resolve()}async _sendLoop(){for(;;){if(await this._sendBufferedData.promise,!this._executing){this._transportResult&&this._transportResult.reject("Connection stopped.");break}this._sendBufferedData=new x;let a=this._transportResult;this._transportResult=void 0;let b="string"==typeof this._buffer[0]?this._buffer.join(""):w._concatBuffers(this._buffer);this._buffer.length=0;try{await this._transport.send(b),a.resolve()}catch(b){a.reject(b)}}}static _concatBuffers(a){let b=new Uint8Array(a.map(a=>a.byteLength).reduce((a,b)=>a+b)),c=0;for(let d of a)b.set(new Uint8Array(d),c),c+=d.byteLength;return b.buffer}}class x{constructor(){this.promise=new Promise((a,b)=>([this._resolver,this._rejecter]=[a,b]))}resolve(){this._resolver()}reject(a){this._rejecter(a)}}a.s(["HttpConnection",()=>v],20316)},72789,a=>{"use strict";class b{static write(a){return`${a}${b.RecordSeparator}`}static parse(a){if(a[a.length-1]!==b.RecordSeparator)throw Error("Message is incomplete.");let c=a.split(b.RecordSeparator);return c.pop(),c}}b.RecordSeparatorCode=30,b.RecordSeparator=String.fromCharCode(b.RecordSeparatorCode),a.s(["TextMessageFormat",()=>b])},75811,a=>{"use strict";var b=a.i(72789),c=a.i(71473);class d{writeHandshakeRequest(a){return b.TextMessageFormat.write(JSON.stringify(a))}parseHandshakeResponse(a){let d,e;if((0,c.isArrayBuffer)(a)){let c=new Uint8Array(a),f=c.indexOf(b.TextMessageFormat.RecordSeparatorCode);if(-1===f)throw Error("Message is incomplete.");let g=f+1;d=String.fromCharCode.apply(null,Array.prototype.slice.call(c.slice(0,g))),e=c.byteLength>g?c.slice(g).buffer:null}else{let c=a.indexOf(b.TextMessageFormat.RecordSeparator);if(-1===c)throw Error("Message is incomplete.");let f=c+1;d=a.substring(0,f),e=a.length>f?a.substring(f):null}let f=JSON.parse(b.TextMessageFormat.parse(d)[0]);if(f.type)throw Error("Expected a handshake response from the server.");return[e,f]}}a.s(["HandshakeProtocol",()=>d])},3207,71019,a=>{"use strict";var b,c,d,e,f=a.i(75811),g=a.i(15591);(b=d||(d={}))[b.Invocation=1]="Invocation",b[b.StreamItem=2]="StreamItem",b[b.Completion=3]="Completion",b[b.StreamInvocation=4]="StreamInvocation",b[b.CancelInvocation=5]="CancelInvocation",b[b.Ping=6]="Ping",b[b.Close=7]="Close",b[b.Ack=8]="Ack",b[b.Sequence=9]="Sequence",a.s(["MessageType",()=>d],71019);var h=a.i(53692),i=a.i(71473);class j{constructor(){this.observers=[]}next(a){for(let b of this.observers)b.next(a)}error(a){for(let b of this.observers)b.error&&b.error(a)}complete(){for(let a of this.observers)a.complete&&a.complete()}subscribe(a){return this.observers.push(a),new i.SubjectSubscription(this,a)}}class k{constructor(a,b,c){this._bufferSize=1e5,this._messages=[],this._totalMessageCount=0,this._waitForSequenceMessage=!1,this._nextReceivingSequenceId=1,this._latestReceivedSequenceId=0,this._bufferedByteCount=0,this._reconnectInProgress=!1,this._protocol=a,this._connection=b,this._bufferSize=c}async _send(a){let b=this._protocol.writeMessage(a),c=Promise.resolve();if(this._isInvocationMessage(a)){this._totalMessageCount++;let a=()=>{},d=()=>{};(0,i.isArrayBuffer)(b)?this._bufferedByteCount+=b.byteLength:this._bufferedByteCount+=b.length,this._bufferedByteCount>=this._bufferSize&&(c=new Promise((b,c)=>{a=b,d=c})),this._messages.push(new l(b,this._totalMessageCount,a,d))}try{this._reconnectInProgress||await this._connection.send(b)}catch{this._disconnected()}await c}_ack(a){let b=-1;for(let c=0;c<this._messages.length;c++){let d=this._messages[c];if(d._id<=a.sequenceId)b=c,(0,i.isArrayBuffer)(d._message)?this._bufferedByteCount-=d._message.byteLength:this._bufferedByteCount-=d._message.length,d._resolver();else if(this._bufferedByteCount<this._bufferSize)d._resolver();else break}-1!==b&&(this._messages=this._messages.slice(b+1))}_shouldProcessMessage(a){if(this._waitForSequenceMessage)if(a.type!==d.Sequence)return!1;else return this._waitForSequenceMessage=!1,!0;if(!this._isInvocationMessage(a))return!0;let b=this._nextReceivingSequenceId;return(this._nextReceivingSequenceId++,b<=this._latestReceivedSequenceId)?(b===this._latestReceivedSequenceId&&this._ackTimer(),!1):(this._latestReceivedSequenceId=b,this._ackTimer(),!0)}_resetSequence(a){a.sequenceId>this._nextReceivingSequenceId?this._connection.stop(Error("Sequence ID greater than amount of messages we've received.")):this._nextReceivingSequenceId=a.sequenceId}_disconnected(){this._reconnectInProgress=!0,this._waitForSequenceMessage=!0}async _resend(){let a=0!==this._messages.length?this._messages[0]._id:this._totalMessageCount+1;for(let b of(await this._connection.send(this._protocol.writeMessage({type:d.Sequence,sequenceId:a})),this._messages))await this._connection.send(b._message);this._reconnectInProgress=!1}_dispose(a){for(let b of(null!=a||(a=Error("Unable to reconnect to server.")),this._messages))b._rejector(a)}_isInvocationMessage(a){switch(a.type){case d.Invocation:case d.StreamItem:case d.Completion:case d.StreamInvocation:case d.CancelInvocation:return!0;case d.Close:case d.Sequence:case d.Ping:case d.Ack:return!1}}_ackTimer(){void 0===this._ackTimerHandle&&(this._ackTimerHandle=setTimeout(async()=>{try{this._reconnectInProgress||await this._connection.send(this._protocol.writeMessage({type:d.Ack,sequenceId:this._latestReceivedSequenceId}))}catch{}clearTimeout(this._ackTimerHandle),this._ackTimerHandle=void 0},1e3))}}class l{constructor(a,b,c,d){this._message=a,this._id=b,this._resolver=c,this._rejector=d}}(c=e||(e={})).Disconnected="Disconnected",c.Connecting="Connecting",c.Connected="Connected",c.Disconnecting="Disconnecting",c.Reconnecting="Reconnecting";class m{static create(a,b,c,d,e,f,g){return new m(a,b,c,d,e,f,g)}constructor(a,b,c,g,j,k,l){this._nextKeepAlive=0,this._freezeEventListener=()=>{this._logger.log(h.LogLevel.Warning,"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep")},i.Arg.isRequired(a,"connection"),i.Arg.isRequired(b,"logger"),i.Arg.isRequired(c,"protocol"),this.serverTimeoutInMilliseconds=null!=j?j:3e4,this.keepAliveIntervalInMilliseconds=null!=k?k:15e3,this._statefulReconnectBufferSize=null!=l?l:1e5,this._logger=b,this._protocol=c,this.connection=a,this._reconnectPolicy=g,this._handshakeProtocol=new f.HandshakeProtocol,this.connection.onreceive=a=>this._processIncomingData(a),this.connection.onclose=a=>this._connectionClosed(a),this._callbacks={},this._methods={},this._closedCallbacks=[],this._reconnectingCallbacks=[],this._reconnectedCallbacks=[],this._invocationId=0,this._receivedHandshakeResponse=!1,this._connectionState=e.Disconnected,this._connectionStarted=!1,this._cachedPingMessage=this._protocol.writeMessage({type:d.Ping})}get state(){return this._connectionState}get connectionId(){return this.connection&&this.connection.connectionId||null}get baseUrl(){return this.connection.baseUrl||""}set baseUrl(a){if(this._connectionState!==e.Disconnected&&this._connectionState!==e.Reconnecting)throw Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");if(!a)throw Error("The HubConnection url must be a valid url.");this.connection.baseUrl=a}start(){return this._startPromise=this._startWithStateTransitions(),this._startPromise}async _startWithStateTransitions(){if(this._connectionState!==e.Disconnected)return Promise.reject(Error("Cannot start a HubConnection that is not in the 'Disconnected' state."));this._connectionState=e.Connecting,this._logger.log(h.LogLevel.Debug,"Starting HubConnection.");try{await this._startInternal(),i.Platform.isBrowser&&window.document.addEventListener("freeze",this._freezeEventListener),this._connectionState=e.Connected,this._connectionStarted=!0,this._logger.log(h.LogLevel.Debug,"HubConnection connected successfully.")}catch(a){return this._connectionState=e.Disconnected,this._logger.log(h.LogLevel.Debug,`HubConnection failed to start successfully because of error '${a}'.`),Promise.reject(a)}}async _startInternal(){this._stopDuringStartError=void 0,this._receivedHandshakeResponse=!1;let a=new Promise((a,b)=>{this._handshakeResolver=a,this._handshakeRejecter=b});await this.connection.start(this._protocol.transferFormat);try{let b=this._protocol.version;this.connection.features.reconnect||(b=1);let c={protocol:this._protocol.name,version:b};if(this._logger.log(h.LogLevel.Debug,"Sending handshake request."),await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(c)),this._logger.log(h.LogLevel.Information,`Using HubProtocol '${this._protocol.name}'.`),this._cleanupTimeout(),this._resetTimeoutPeriod(),this._resetKeepAliveInterval(),await a,this._stopDuringStartError)throw this._stopDuringStartError;(this.connection.features.reconnect||0)&&(this._messageBuffer=new k(this._protocol,this.connection,this._statefulReconnectBufferSize),this.connection.features.disconnected=this._messageBuffer._disconnected.bind(this._messageBuffer),this.connection.features.resend=()=>{if(this._messageBuffer)return this._messageBuffer._resend()}),this.connection.features.inherentKeepAlive||await this._sendMessage(this._cachedPingMessage)}catch(a){throw this._logger.log(h.LogLevel.Debug,`Hub handshake failed with error '${a}' during start(). Stopping HubConnection.`),this._cleanupTimeout(),this._cleanupPingTimer(),await this.connection.stop(a),a}}async stop(){let a=this._startPromise;this.connection.features.reconnect=!1,this._stopPromise=this._stopInternal(),await this._stopPromise;try{await a}catch(a){}}_stopInternal(a){if(this._connectionState===e.Disconnected)return this._logger.log(h.LogLevel.Debug,`Call to HubConnection.stop(${a}) ignored because it is already in the disconnected state.`),Promise.resolve();if(this._connectionState===e.Disconnecting)return this._logger.log(h.LogLevel.Debug,`Call to HttpConnection.stop(${a}) ignored because the connection is already in the disconnecting state.`),this._stopPromise;let b=this._connectionState;return(this._connectionState=e.Disconnecting,this._logger.log(h.LogLevel.Debug,"Stopping HubConnection."),this._reconnectDelayHandle)?(this._logger.log(h.LogLevel.Debug,"Connection stopped during reconnect delay. Done reconnecting."),clearTimeout(this._reconnectDelayHandle),this._reconnectDelayHandle=void 0,this._completeClose(),Promise.resolve()):(b===e.Connected&&this._sendCloseMessage(),this._cleanupTimeout(),this._cleanupPingTimer(),this._stopDuringStartError=a||new g.AbortError("The connection was stopped before the hub handshake could complete."),this.connection.stop(a))}async _sendCloseMessage(){try{await this._sendWithProtocol(this._createCloseMessage())}catch{}}stream(a,...b){let c,[e,f]=this._replaceStreamingParams(b),g=this._createStreamInvocation(a,b,f),h=new j;return h.cancelCallback=()=>{let a=this._createCancelInvocation(g.invocationId);return delete this._callbacks[g.invocationId],c.then(()=>this._sendWithProtocol(a))},this._callbacks[g.invocationId]=(a,b)=>{b?h.error(b):a&&(a.type===d.Completion?a.error?h.error(Error(a.error)):h.complete():h.next(a.item))},c=this._sendWithProtocol(g).catch(a=>{h.error(a),delete this._callbacks[g.invocationId]}),this._launchStreams(e,c),h}_sendMessage(a){return this._resetKeepAliveInterval(),this.connection.send(a)}_sendWithProtocol(a){return this._messageBuffer?this._messageBuffer._send(a):this._sendMessage(this._protocol.writeMessage(a))}send(a,...b){let[c,d]=this._replaceStreamingParams(b),e=this._sendWithProtocol(this._createInvocation(a,b,!0,d));return this._launchStreams(c,e),e}invoke(a,...b){let[c,e]=this._replaceStreamingParams(b),f=this._createInvocation(a,b,!1,e);return new Promise((a,b)=>{this._callbacks[f.invocationId]=(c,e)=>{e?b(e):c&&(c.type===d.Completion?c.error?b(Error(c.error)):a(c.result):b(Error(`Unexpected message type: ${c.type}`)))};let e=this._sendWithProtocol(f).catch(a=>{b(a),delete this._callbacks[f.invocationId]});this._launchStreams(c,e)})}on(a,b){a&&b&&(a=a.toLowerCase(),this._methods[a]||(this._methods[a]=[]),-1===this._methods[a].indexOf(b)&&this._methods[a].push(b))}off(a,b){if(!a)return;a=a.toLowerCase();let c=this._methods[a];if(c)if(b){let d=c.indexOf(b);-1!==d&&(c.splice(d,1),0===c.length&&delete this._methods[a])}else delete this._methods[a]}onclose(a){a&&this._closedCallbacks.push(a)}onreconnecting(a){a&&this._reconnectingCallbacks.push(a)}onreconnected(a){a&&this._reconnectedCallbacks.push(a)}_processIncomingData(a){if(this._cleanupTimeout(),this._receivedHandshakeResponse||(a=this._processHandshakeResponse(a),this._receivedHandshakeResponse=!0),a){for(let b of this._protocol.parseMessages(a,this._logger))if(!this._messageBuffer||this._messageBuffer._shouldProcessMessage(b))switch(b.type){case d.Invocation:this._invokeClientMethod(b).catch(a=>{this._logger.log(h.LogLevel.Error,`Invoke client method threw error: ${(0,i.getErrorString)(a)}`)});break;case d.StreamItem:case d.Completion:{let a=this._callbacks[b.invocationId];if(a){b.type===d.Completion&&delete this._callbacks[b.invocationId];try{a(b)}catch(a){this._logger.log(h.LogLevel.Error,`Stream callback threw error: ${(0,i.getErrorString)(a)}`)}}break}case d.Ping:break;case d.Close:{this._logger.log(h.LogLevel.Information,"Close message received from server.");let a=b.error?Error("Server returned an error on close: "+b.error):void 0;!0===b.allowReconnect?this.connection.stop(a):this._stopPromise=this._stopInternal(a);break}case d.Ack:this._messageBuffer&&this._messageBuffer._ack(b);break;case d.Sequence:this._messageBuffer&&this._messageBuffer._resetSequence(b);break;default:this._logger.log(h.LogLevel.Warning,`Invalid message type: ${b.type}.`)}}this._resetTimeoutPeriod()}_processHandshakeResponse(a){let b,c;try{[c,b]=this._handshakeProtocol.parseHandshakeResponse(a)}catch(c){let a="Error parsing handshake response: "+c;this._logger.log(h.LogLevel.Error,a);let b=Error(a);throw this._handshakeRejecter(b),b}if(b.error){let a="Server returned handshake error: "+b.error;this._logger.log(h.LogLevel.Error,a);let c=Error(a);throw this._handshakeRejecter(c),c}return this._logger.log(h.LogLevel.Debug,"Server handshake complete."),this._handshakeResolver(),c}_resetKeepAliveInterval(){this.connection.features.inherentKeepAlive||(this._nextKeepAlive=new Date().getTime()+this.keepAliveIntervalInMilliseconds,this._cleanupPingTimer())}_resetTimeoutPeriod(){if(!this.connection.features||!this.connection.features.inherentKeepAlive){this._timeoutHandle=setTimeout(()=>this.serverTimeout(),this.serverTimeoutInMilliseconds);let a=this._nextKeepAlive-new Date().getTime();if(a<0){this._connectionState===e.Connected&&this._trySendPingMessage();return}void 0===this._pingServerHandle&&(a<0&&(a=0),this._pingServerHandle=setTimeout(async()=>{this._connectionState===e.Connected&&await this._trySendPingMessage()},a))}}serverTimeout(){this.connection.stop(Error("Server timeout elapsed without receiving a message from the server."))}async _invokeClientMethod(a){let b,c,d,e=a.target.toLowerCase(),f=this._methods[e];if(!f){this._logger.log(h.LogLevel.Warning,`No client method with the name '${e}' found.`),a.invocationId&&(this._logger.log(h.LogLevel.Warning,`No result given for '${e}' method and invocation ID '${a.invocationId}'.`),await this._sendWithProtocol(this._createCompletionMessage(a.invocationId,"Client didn't provide a result.",null)));return}let g=f.slice(),i=!!a.invocationId;for(let f of g)try{let g=b;b=await f.apply(this,a.arguments),i&&b&&g&&(this._logger.log(h.LogLevel.Error,`Multiple results provided for '${e}'. Sending error to server.`),d=this._createCompletionMessage(a.invocationId,"Client provided multiple results.",null)),c=void 0}catch(a){c=a,this._logger.log(h.LogLevel.Error,`A callback for the method '${e}' threw error '${a}'.`)}d?await this._sendWithProtocol(d):i?(c?d=this._createCompletionMessage(a.invocationId,`${c}`,null):void 0!==b?d=this._createCompletionMessage(a.invocationId,null,b):(this._logger.log(h.LogLevel.Warning,`No result given for '${e}' method and invocation ID '${a.invocationId}'.`),d=this._createCompletionMessage(a.invocationId,"Client didn't provide a result.",null)),await this._sendWithProtocol(d)):b&&this._logger.log(h.LogLevel.Error,`Result given for '${e}' method but server is not expecting a result.`)}_connectionClosed(a){this._logger.log(h.LogLevel.Debug,`HubConnection.connectionClosed(${a}) called while in state ${this._connectionState}.`),this._stopDuringStartError=this._stopDuringStartError||a||new g.AbortError("The underlying connection was closed before the hub handshake could complete."),this._handshakeResolver&&this._handshakeResolver(),this._cancelCallbacksWithError(a||Error("Invocation canceled due to the underlying connection being closed.")),this._cleanupTimeout(),this._cleanupPingTimer(),this._connectionState===e.Disconnecting?this._completeClose(a):this._connectionState===e.Connected&&this._reconnectPolicy?this._reconnect(a):this._connectionState===e.Connected&&this._completeClose(a)}_completeClose(a){if(this._connectionStarted){this._connectionState=e.Disconnected,this._connectionStarted=!1,this._messageBuffer&&(this._messageBuffer._dispose(null!=a?a:Error("Connection closed.")),this._messageBuffer=void 0),i.Platform.isBrowser&&window.document.removeEventListener("freeze",this._freezeEventListener);try{this._closedCallbacks.forEach(b=>b.apply(this,[a]))}catch(b){this._logger.log(h.LogLevel.Error,`An onclose callback called with error '${a}' threw error '${b}'.`)}}}async _reconnect(a){let b=Date.now(),c=0,d=void 0!==a?a:Error("Attempting to reconnect due to a unknown error."),f=this._getNextRetryDelay(c,0,d);if(null===f){this._logger.log(h.LogLevel.Debug,"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."),this._completeClose(a);return}if(this._connectionState=e.Reconnecting,a?this._logger.log(h.LogLevel.Information,`Connection reconnecting because of error '${a}'.`):this._logger.log(h.LogLevel.Information,"Connection reconnecting."),0!==this._reconnectingCallbacks.length){try{this._reconnectingCallbacks.forEach(b=>b.apply(this,[a]))}catch(b){this._logger.log(h.LogLevel.Error,`An onreconnecting callback called with error '${a}' threw error '${b}'.`)}if(this._connectionState!==e.Reconnecting)return void this._logger.log(h.LogLevel.Debug,"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.")}for(;null!==f;){if(this._logger.log(h.LogLevel.Information,`Reconnect attempt number ${c+1} will start in ${f} ms.`),await new Promise(a=>{this._reconnectDelayHandle=setTimeout(a,f)}),this._reconnectDelayHandle=void 0,this._connectionState!==e.Reconnecting)return void this._logger.log(h.LogLevel.Debug,"Connection left the reconnecting state during reconnect delay. Done reconnecting.");try{if(await this._startInternal(),this._connectionState=e.Connected,this._logger.log(h.LogLevel.Information,"HubConnection reconnected successfully."),0!==this._reconnectedCallbacks.length)try{this._reconnectedCallbacks.forEach(a=>a.apply(this,[this.connection.connectionId]))}catch(a){this._logger.log(h.LogLevel.Error,`An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${a}'.`)}return}catch(a){if(this._logger.log(h.LogLevel.Information,`Reconnect attempt failed because of error '${a}'.`),this._connectionState!==e.Reconnecting){this._logger.log(h.LogLevel.Debug,`Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`),this._connectionState===e.Disconnecting&&this._completeClose();return}c++,d=a instanceof Error?a:Error(a.toString()),f=this._getNextRetryDelay(c,Date.now()-b,d)}}this._logger.log(h.LogLevel.Information,`Reconnect retries have been exhausted after ${Date.now()-b} ms and ${c} failed attempts. Connection disconnecting.`),this._completeClose()}_getNextRetryDelay(a,b,c){try{return this._reconnectPolicy.nextRetryDelayInMilliseconds({elapsedMilliseconds:b,previousRetryCount:a,retryReason:c})}catch(c){return this._logger.log(h.LogLevel.Error,`IRetryPolicy.nextRetryDelayInMilliseconds(${a}, ${b}) threw error '${c}'.`),null}}_cancelCallbacksWithError(a){let b=this._callbacks;this._callbacks={},Object.keys(b).forEach(c=>{let d=b[c];try{d(null,a)}catch(b){this._logger.log(h.LogLevel.Error,`Stream 'error' callback called with '${a}' threw error: ${(0,i.getErrorString)(b)}`)}})}_cleanupPingTimer(){this._pingServerHandle&&(clearTimeout(this._pingServerHandle),this._pingServerHandle=void 0)}_cleanupTimeout(){this._timeoutHandle&&clearTimeout(this._timeoutHandle)}_createInvocation(a,b,c,e){if(c)if(0!==e.length)return{target:a,arguments:b,streamIds:e,type:d.Invocation};else return{target:a,arguments:b,type:d.Invocation};{let c=this._invocationId;return(this._invocationId++,0!==e.length)?{target:a,arguments:b,invocationId:c.toString(),streamIds:e,type:d.Invocation}:{target:a,arguments:b,invocationId:c.toString(),type:d.Invocation}}}_launchStreams(a,b){if(0!==a.length)for(let c in b||(b=Promise.resolve()),a)a[c].subscribe({complete:()=>{b=b.then(()=>this._sendWithProtocol(this._createCompletionMessage(c)))},error:a=>{let d;d=a instanceof Error?a.message:a&&a.toString?a.toString():"Unknown error",b=b.then(()=>this._sendWithProtocol(this._createCompletionMessage(c,d)))},next:a=>{b=b.then(()=>this._sendWithProtocol(this._createStreamItemMessage(c,a)))}})}_replaceStreamingParams(a){let b=[],c=[];for(let d=0;d<a.length;d++){let e=a[d];if(this._isObservable(e)){let f=this._invocationId;this._invocationId++,b[f]=e,c.push(f.toString()),a.splice(d,1)}}return[b,c]}_isObservable(a){return a&&a.subscribe&&"function"==typeof a.subscribe}_createStreamInvocation(a,b,c){let e=this._invocationId;return(this._invocationId++,0!==c.length)?{target:a,arguments:b,invocationId:e.toString(),streamIds:c,type:d.StreamInvocation}:{target:a,arguments:b,invocationId:e.toString(),type:d.StreamInvocation}}_createCancelInvocation(a){return{invocationId:a,type:d.CancelInvocation}}_createStreamItemMessage(a,b){return{invocationId:a,item:b,type:d.StreamItem}}_createCompletionMessage(a,b,c){return b?{error:b,invocationId:a,type:d.Completion}:{invocationId:a,result:c,type:d.Completion}}_createCloseMessage(){return{type:d.Close}}async _trySendPingMessage(){try{await this._sendMessage(this._cachedPingMessage)}catch{this._cleanupPingTimer()}}}a.s(["HubConnection",()=>m,"HubConnectionState",()=>e],3207)},12584,a=>{"use strict";var b=a.i(34951),c=a.i(20316),d=a.i(3207),e=a.i(53692),f=a.i(71019),g=a.i(65581),h=a.i(82968),i=a.i(72789);class j{constructor(){this.name="json",this.version=2,this.transferFormat=g.TransferFormat.Text}parseMessages(a,b){if("string"!=typeof a)throw Error("Invalid input for JSON hub protocol. Expected a string.");if(!a)return[];null===b&&(b=h.NullLogger.instance);let c=i.TextMessageFormat.parse(a),d=[];for(let a of c){let c=JSON.parse(a);if("number"!=typeof c.type)throw Error("Invalid payload.");switch(c.type){case f.MessageType.Invocation:this._isInvocationMessage(c);break;case f.MessageType.StreamItem:this._isStreamItemMessage(c);break;case f.MessageType.Completion:this._isCompletionMessage(c);break;case f.MessageType.Ping:case f.MessageType.Close:break;case f.MessageType.Ack:this._isAckMessage(c);break;case f.MessageType.Sequence:this._isSequenceMessage(c);break;default:b.log(e.LogLevel.Information,"Unknown message type '"+c.type+"' ignored.");continue}d.push(c)}return d}writeMessage(a){return i.TextMessageFormat.write(JSON.stringify(a))}_isInvocationMessage(a){this._assertNotEmptyString(a.target,"Invalid payload for Invocation message."),void 0!==a.invocationId&&this._assertNotEmptyString(a.invocationId,"Invalid payload for Invocation message.")}_isStreamItemMessage(a){if(this._assertNotEmptyString(a.invocationId,"Invalid payload for StreamItem message."),void 0===a.item)throw Error("Invalid payload for StreamItem message.")}_isCompletionMessage(a){if(a.result&&a.error)throw Error("Invalid payload for Completion message.");!a.result&&a.error&&this._assertNotEmptyString(a.error,"Invalid payload for Completion message."),this._assertNotEmptyString(a.invocationId,"Invalid payload for Completion message.")}_isAckMessage(a){if("number"!=typeof a.sequenceId)throw Error("Invalid SequenceId for Ack message.")}_isSequenceMessage(a){if("number"!=typeof a.sequenceId)throw Error("Invalid SequenceId for Sequence message.")}_assertNotEmptyString(a,b){if("string"!=typeof a||""===a)throw Error(b)}}var k=a.i(71473);let l={trace:e.LogLevel.Trace,debug:e.LogLevel.Debug,info:e.LogLevel.Information,information:e.LogLevel.Information,warn:e.LogLevel.Warning,warning:e.LogLevel.Warning,error:e.LogLevel.Error,critical:e.LogLevel.Critical,none:e.LogLevel.None};class m{configureLogging(a){if(k.Arg.isRequired(a,"logging"),void 0!==a.log)this.logger=a;else if("string"==typeof a){let b=function(a){let b=l[a.toLowerCase()];if(void 0!==b)return b;throw Error(`Unknown log level: ${a}`)}(a);this.logger=new k.ConsoleLogger(b)}else this.logger=new k.ConsoleLogger(a);return this}withUrl(a,b){return k.Arg.isRequired(a,"url"),k.Arg.isNotEmpty(a,"url"),this.url=a,"object"==typeof b?this.httpConnectionOptions={...this.httpConnectionOptions,...b}:this.httpConnectionOptions={...this.httpConnectionOptions,transport:b},this}withHubProtocol(a){return k.Arg.isRequired(a,"protocol"),this.protocol=a,this}withAutomaticReconnect(a){if(this.reconnectPolicy)throw Error("A reconnectPolicy has already been set.");return a?Array.isArray(a)?this.reconnectPolicy=new b.DefaultReconnectPolicy(a):this.reconnectPolicy=a:this.reconnectPolicy=new b.DefaultReconnectPolicy,this}withServerTimeout(a){return k.Arg.isRequired(a,"milliseconds"),this._serverTimeoutInMilliseconds=a,this}withKeepAliveInterval(a){return k.Arg.isRequired(a,"milliseconds"),this._keepAliveIntervalInMilliseconds=a,this}withStatefulReconnect(a){return void 0===this.httpConnectionOptions&&(this.httpConnectionOptions={}),this.httpConnectionOptions._useStatefulReconnect=!0,this._statefulReconnectBufferSize=null==a?void 0:a.bufferSize,this}build(){let a=this.httpConnectionOptions||{};if(void 0===a.logger&&(a.logger=this.logger),!this.url)throw Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");let b=new c.HttpConnection(this.url,a);return d.HubConnection.create(b,this.logger||h.NullLogger.instance,this.protocol||new j,this.reconnectPolicy,this._serverTimeoutInMilliseconds,this._keepAliveIntervalInMilliseconds,this._statefulReconnectBufferSize)}}a.s(["HubConnectionBuilder",()=>m],12584)}];

//# sourceMappingURL=node_modules_%40microsoft_signalr_dist_esm_3b527ece._.js.map